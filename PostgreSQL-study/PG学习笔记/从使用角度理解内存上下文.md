# 从使用角度理解内存上下文

by 刘海峰  2020.12.09

## 背景

之前已有同事从实现角度对内存上下文进行了深入分析， 本文从使用者的角度对内存上下文进行阐述。

## 使用内存上下文的优点

* 内存上下文使得可以自由分配内存， 而不必费心去释放, 尤其当内存指针被多次复制及传递时。

  > 可以像Java, C#等高级语言一样, 只管palloc，而不用考虑pfree。
  >
  > 当然，显式的调用pfree()可以让内存的释放更加提前，提升内存使用效率。

* 将内存分配在合适的上下文中，可以保证当分配的内存不再使用时, 能够被及时的释放, 降低操作系统内存压力。

  > 不同上下文的重设（即内存释放）的时机是不同的，将内存分配在合适的上下文中，可以保证不再使用的内存被及时的回收，从而提高内存使用效率，降低物理内存压力。

* 对于大量、频繁的小内存的分配和释放，内存上下文提供了“内存池”的机制， 相比于malloc和free， 能够提升性能，并且减少物理内存碎片化程度。

  > 大量、频繁的进行小内存的malloc和free，一方面会有累积的性能开销，另一方面长时间会造成物理内存碎片很多，容易导致大块内存分配失败的情况发生。

* 使用内存上下文分配内存，调用者永远不用考虑返回值为NULL的情况，相比于malloc、realloc，无需添加判空逻辑，使代码更加简洁。

  > 内存上下文保证“palloc，repalloc"时永远不会返回NULL，在其内部，如果分配内存失败，会抛出友好的错误，而非coredump。
  >
  > 使用malloc需要进行判空，否则NULL会导致coredump。
  >
  > 
  >
  > 相当于“palloc，repalloc"在内部已经帮你把"异常错误"的情况都给处理了, 并且还是统一的, 标准的处理.

* 使用内存上下文palloc0()分配内存，分配后的内存默认已经初始化为0，调用者无需再调用memset()，使代码更加简洁。

  > palloc0()内部默认调用了自定义的Memset()，一方面减少简化调用者代码，另一方面Memset()比memset()更加高效。

* 使用内存上下文pstrdup()来复制字符串，十分方便.

  >  一般复制字符串需要如下步骤, 麻烦并且容易内存泄漏。
  >
  >  ```c
  >  len = strlen(str);
  >  p = malloc(len+1);
  >  if (!p) xxx   /* 需要判空处理, 否则NULL会造成coredump */
  >  memcpy(p, str， len);
  >  p[len] = '\0';
  >  /* use p */
  >  free(p);	/* 使用完了, 很容易忘记释放p指向的内存 */
  >  ```
  >
  >  使用内存上下文的pstrdup()。
  >
  >  ```c
  >  strcopy = pstrdup(str);
  >  ```
  >
  >  

## Q & A
### Q 在内存上下文分配内存，一定可以避免内存泄漏吗？

先确定“内存泄漏”的定义： 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程勋运行速度减慢甚至系统崩溃等严重后果。

根据上述定义，如果将内存分配到 TopMemoryContext上，将意味着只有当对应的进程退出时，分配在TopMemoryContext的内存才会被释放，对于一个“守护进程”或“长时间执行事务的backend进程”，将大量“短生命周期内存”分配到TopMemoryContext上，就不是明智之举，可能会造成所谓的“内存泄漏”。

### Q 在分配内存之前如何选择切换到合适的内存上下文？

在backend进程中，先确认自己分配的内存的使用生命周期，然后根据生命周期，来选择切换到合适的默认内存上下文中分配内存。

>  注意： 如果确认的生命周期为T1，内存上下文管理生命周期为T2，那么合适的内存上下文至少应该要保证 T2 >= T1；否则会出现正在使用中的内存被提前释放，从而导致异常错误。

### Q UXDB默认的内存上下文都有哪些？各自的重设时机？

```c
MemoryContext TopMemoryContext = NULL;
MemoryContext ErrorContext = NULL;
MemoryContext PostmasterContext = NULL;
MemoryContext CacheMemoryContext = NULL;
MemoryContext MessageContext = NULL;
MemoryContext TopTransactionContext = NULL;
MemoryContext CurTransactionContext = NULL;

/* This is a transient link to the active portal's memory context: */
MemoryContext PortalContext = NULL;
```

TopMemoryContext：可以管理任意生命周期内存，但也是最不及时的，一直到进程结束时才会释放管理的内存。

> 将内存分配到这里, 起不到"内存上下文"管理的作用.

ErrorContext：发生错误elog（ERRO），ereport（ERROR）时，释放一次。

PostmasterContext： 每次生成一个backend后， 释放一次。

CacheMemoryContext：relcache、catcache和相关模块的永久存储。它也不会被重置或删除，因此实际上没有必要将其与TopMemoryContext区分开来。但是为了调试的目的，保持这种区别似乎是值得的。(注意:CacheMemoryContext具有寿命较短的子上下文。例如，子上下文是保持与relcache条目关联的子存储的最佳位置;这样，我们就可以轻松地释放规则解析树等等，而不必依赖于构造一个可靠的freeObject()版本。

MessageContext：此上下文保存来自前端的当前命令消息，以及仅需要与当前消息存活时间一样长的任何派生存储(例如，在简单查询模式下，解析树和计划树可以在这里生存)。在PostgresMain的外循环的每个循环的顶部，这个上下文将被重置，所有子上下文将被删除。这与每个事务和每个门户上下文是分开的，因为查询字符串可能需要比任何单个事务或门户存在更长的或更短的时间。

TopTransactionContext：适合管理一个父事务生命周期内的内存；父事务结束时，内存就会释放。

CurTransactionContext：适合管理一个事务（子事务或父事务）生命周期内的内存；事务结束时内存就会释放。

PortalContext：适合管理一个Portal生命周期内的内存；Portal接收时内存就会释放。

> 一个Portal简单理解, 就是执行一条SQL语句的生命周期.

### Q 什么情况下有必要创建自己的内存上下文?

* 如果在守护进程中，需要对守护进程中所有内存的生命周期进行归类，根据归类创建对应的内存上下文，然后将不同生命周期的内存交由对应的内存上下文来管理，并且在对应的时机中，重设（即释放内存）指定的内存上下文，已达到对内存管理的自动化和高效化，并防止内存泄漏。
* 对于长时间运行的守护进程，是否需要创建自定义的内存上下文，以及创建何种类的上下文，需要根据自身的业务需求和实现逻辑来确定。如果不使用内存上下文，全部靠手工管理，那么理论上对内存的使用管理肯定是最高效的，并且内存泄漏也要全靠人工负责。
* 如果业务逻辑比较复杂，通过设计“坚固"的数据结构(来保证内存不泄漏)代价比较大时甚至不可能时，或者无法完全解决“偶发式“的内存泄漏，那么就可以有选择的使用内存上下文来管理内存。

### Q 自定义内存上下文和数据库已有的内存上下文使用关系.

数据库已有的内存上下文已经是一个"树"结构，将自定义的内存上下文添加已有“树”的合适节点，作为其“子节点”即可。



## 参考文档

backend/utils/mmgr/README

