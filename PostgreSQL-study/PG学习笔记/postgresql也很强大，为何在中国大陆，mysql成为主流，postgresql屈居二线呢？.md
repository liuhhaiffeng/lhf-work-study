## [*postgresql*也很强大，为何在中国大陆，mysql成为主流，*postgresql*屈居二线呢？](https://www.zhihu.com/question/31955622/answer/1625152059)

[![大宽宽](https://pic4.zhimg.com/50/v2-0d277f6cffdf1141d9aaa7763b92b9d7_s.jpg?source=4e949a73)](https://www.zhihu.com/people/xing-jiankuan)

[大宽宽](https://www.zhihu.com/people/xing-jiankuan)

飞书-喜欢刨根问底的攻城师

以下均为个人感觉，没做过统计，就当个参考吧。

mysql和postgres的早期完全是两个极端。mysql更像是个“基本上满足关系数据库语法的大号KV”，对关系型数据库的高级功能支持的很不好。我入行时接触的MySQL 5.1和MyISAM存储引擎，不支持ACID，但有如下几点在当时的互联网公司看来是非常合适：

- 互联网公司为了扩展，长期的经验是，仅仅把数据库当作是一个“存储”，而非存储+核心数据逻辑的计算节点。大量的计算都在业务服务器上进行，而业务服务器可以无限水平扩展，而无需担心有状态的数据迁移问题；
- 因为没有提供很多高级功能和数据一致性的保障，mysql对于简单的sql支持的反而更加直接，在速度上有很大的优势；
- 对于OLTP，完全不需要复杂的数据处理功能。简单的select ... from ... where id = xxx; insert into xxx；update xxx set xxx=xxx where id = xxxx是OLTP的主流功能。基于这些功能的ORM的出现大大的提高了生产效率；对于OLAP，尽管postgres查询分析功能很强，但是一般互联网公司的数据量实在太大，用postgres这种数据库根本无法处理。通常会用MapReduce，Hive，Pig等大数据处理工具来分析；
- 多线程模型，天然对高并发支持良好。而pg一直是多进程模型。进程的创建会更慢，更耗内存。虽然有些pg的连接池方案，但是mysql在这方面“开箱即用”；
- postgres早期并不支持“逻辑复制”。物理复制意味着存储格式的细节完全暴露，不兼容的版本无法直接组成主从同步，于是无法做滚动升级。这就意味着在升级数据库时，必须停服，把整个集群升级后再恢复。而mysql从一开始就是逻辑复制（这其实是由于mysql一直是server和存储引擎分层的架构，逻辑复制发生在server层）。这个缺陷会让postgres的运营不受业务开发者的待见。谁也不希望自己的业务停服。

反过来再看postgres的优点，会发现对于OLTP并没有太大的吸引力：

1. 丰富的数据类型 - 通常用处不大，常用类型足够了。如果有复杂类型，业务上自己序列化，存储成varchar就行。可以用json，PB，avro等。序列化反序列化都发生在业务服务器，更好维护和优化；
2. 强大的审计函数 - 互联网早期活下来是一切，审计并不是核心需求（通常需要严格审计的领域早就会用Oracle/MSql，不差钱）；
3. 强大的索引。postgres的自定义索引功能很强大。但是对于mysql，关键的几列有索引就够了，不需要复杂的高级索引。我承认早期mysql的查询优化器智商堪忧，但如果要改，一句explain，然后force index也就是了。对于开发人员简单直接。有一段时间LBS很流行，当时mongo很潮的直接支持了空间索引。当时大家纷纷的“NoSQL”，就更不会看postgres一眼。然后到了大概2015年，mysql 5.7也支持空间索引了。
4. Posgres的MVCC实现牛逼不，牛。serial snapshot isolation是很强。但是到了需要变更数据严格一致的时候，select ... for update又不是不能用：）
5. 对于序列号，sequence是很好。但是互联网公司对于简单场景用auto increment。对于生产场景就直接用分布式序列号生成服务了。postgres的序列号产生器～偏鸡肋。
6. Postgres的全文索引很强，但强的过ES？强的过专门定制的搜索引擎系统？要知道搜索业务最关键的是把“最匹配搜索人需要的搜索结果返回出来“，而不是仅仅”能搜到一堆不分主次但满足关键字匹配的结果“。

因此早期mysql变成了事实上的互联网企业OLTP的事实标准。不管干啥业务，mysql都不可或缺。在行业里跳槽来跳槽去的程序员普遍对mysql也更熟悉。大量围绕mysql的商业服务都成为了行业主流。新一代分布式数据库，像TiDB为了吸引用户，首先要做的是“兼容mysql的语法”。

再往后，mysql增加了更多“关系型数据库该有的”功能，比如完全支持ACID的innodb成为默认存储引擎，比如5.7的json原生支持，8.0的window function/CTE。而postgres也增加了更多的“互联网功能”。但是时机已经过去了。大家mysql跑着业务好好的。而切换数据库绝对不是仅仅像某些ORM标榜的换一个Dialect就行的。而是整个编程模型，性能表现，运维工具和流程都要有巨大的变化。如非必要，犯不着为了一个“most advanced"的标语去折腾，更不会为了数据库爱好者的情怀做伤害利益的事情。