## PostgreSQL 全局Oid生成器实现原理

刘海峰 2020.08.29



## Oid的分配

Oid 分配由系统中的一个全局生成器来实现，每次需要分配新的Oid时，就从该生成器中取出当前的Oid， 然后给该生成器加1。Oid分配时会采用互斥锁加以锁定以避免多个要求分配Oid的请求获得同一个Oid。

Oid GetNewObject（void）

```c
/*
 * GetNewObjectId -- allocate a new OID
 *
 * 分配一个新的OID
 *
 * OIDs are generated by a cluster-wide counter.  Since they are only 32 bits
 * wide, counter wraparound will occur eventually, and therefore it is unwise
 * to assume they are unique unless precautions are taken to make them so.
 * Hence, this routine should generally not be used directly.  The only
 * direct callers should be GetNewOid() and GetNewRelFileNode() in
 * catalog/catalog.c.
 *
 * OID是由集簇级别的生成器生成的, 但是Oid只有32bit, 所有很有可能会发生回卷, 因此不能假定
 * OID在集簇级别是全局唯一的, 除非采取了预防措施保证其(在xx级别)是唯一的.
 * 因此, 不建议直接调用此函数, 而是使用GetNewOid()或GetNewRelFileNode().
 */
Oid
GetNewObjectId(void)
{
	Oid			result;

	/* safety check, we should never get this far in a HS standby 
	 * 数据库恢复期间不能使用此函数
	 */
	if (RecoveryInProgress())
		elog(ERROR, "cannot assign OIDs during recovery");

    /* 全局Oid生成器使用OidGenLock 互斥锁来进行保护, 以避免多个要求分配OID的请求
     * 获得同一个OID
     */
	LWLockAcquire(OidGenLock, LW_EXCLUSIVE);

	/*
	 * Check for wraparound of the OID counter.  We *must* not return 0
	 * (InvalidOid); and as long as we have to check that, it seems a good
	 * idea to skip over everything below FirstNormalObjectId too. (This
	 * basically just avoids lots of collisions with bootstrap-assigned OIDs
	 * right after a wrap occurs, so as to avoid a possibly large number of
	 * iterations in GetNewOid.)  Note we are relying on unsigned comparison.
	 *
	 * During initdb, we start the OID generator at FirstBootstrapObjectId, so
	 * we only wrap if before that point when in bootstrap or standalone mode.
	 * The first time through this routine after normal postmaster start, the
	 * counter will be forced up to FirstNormalObjectId.  This mechanism
	 * leaves the OIDs between FirstBootstrapObjectId and FirstNormalObjectId
	 * available for automatic assignment during initdb, while ensuring they
	 * will never conflict with user-assigned OIDs.
	 * 
	 * 检查OID生成器的回卷情况, 保证不能返回0这样的无效OID的情况发生.
	 *
	 * initdb时, OID生成器被启动, 第1个有效的OID为FirstBootstrapObjectId, 
	 */
	if (ShmemVariableCache->nextOid < ((Oid) FirstNormalObjectId))
	{
		if (IsPostmasterEnvironment)
		{
			/* wraparound, or first post-initdb assignment, in normal mode */
			ShmemVariableCache->nextOid = FirstNormalObjectId;
			ShmemVariableCache->oidCount = 0;
		}
		else
		{
			/* we may be bootstrapping, so don't enforce the full range */
			if (ShmemVariableCache->nextOid < ((Oid) FirstBootstrapObjectId))
			{
				/* wraparound in standalone mode (unlikely but possible) */
				ShmemVariableCache->nextOid = FirstNormalObjectId;
				ShmemVariableCache->oidCount = 0;
			}
		}
	}

	/* If we run out of logged for use oids then we must log more */
	if (ShmemVariableCache->oidCount == 0)
	{
		XLogPutNextOid(ShmemVariableCache->nextOid + VAR_OID_PREFETCH);
		ShmemVariableCache->oidCount = VAR_OID_PREFETCH;
	}
	
    /* 生成新的OID */
	result = ShmemVariableCache->nextOid;

    /* 预留下一个请求的OID */
	(ShmemVariableCache->nextOid)++;
	(ShmemVariableCache->oidCount)--;
	
    /* 释放保护锁 */
	LWLockRelease(OidGenLock);

	return result;
}
```

