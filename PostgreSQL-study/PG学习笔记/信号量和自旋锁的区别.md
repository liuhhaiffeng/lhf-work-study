# 信号量和自旋锁的区别

by 刘海峰 2020.12.16

## 背景

PG数据库中使用到了信号量和自旋锁, 其中信号量用于Latch的底层实现(注: PG10 已经由信号量改为了原子变量), SpinLock对应的是自旋锁, 搞清楚信号量和自旋锁的区别, 对于理解PG内核中的锁机制以及性能优化是必要的.

## 概述

Linux中的信号量是一种睡眠锁。如果有一个任务试图获得一个不可用（已经被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。这时处理器能重获自由，从而去执行其他代码。当持有的信号量可用（被释放）后，处于等待队列中的那个任务将被唤醒，并获得该信号量

 **信号量和自旋锁的区别：**

（1）信号量不会禁止内核抢占，持有信号量的代码可以抢占，而自旋锁不可以。这意味着信号量不会对调度的等待时间带来负面影响

（2）自旋锁只适合持锁时间短的，因为请求线程在此过程中有两次上下文的切换，被阻塞的线程要换出和换入，与实现自旋锁的少数几行代码相比，上下文切换当然代码多。相反，锁被短时间持有，使用信号量就不太合适了。因为睡眠、维护等待队列以及唤醒所花费的开销可能比锁被占用的全部时间还要长

（3）在你占用信号量的同时不能占用自旋锁。因为在你等待信号量时也可能会睡眠，而在持有自旋锁时是不允许睡眠的

（4）何时用自旋锁何时用信号量可以根据锁被持有的时间长短来判断

（5）信号量同时允许任意数量的锁持有者，而自旋锁在一个时刻最多允许一个任务持有它

参考: [信号量以及信号量和自旋锁的区别](https://blog.csdn.net/yl970302/article/details/90078968)

## 自旋锁、信号量、互斥锁的介绍和区别

信号量一般又叫做信号灯，协调不同进程间的数据对象的，本质上是一个计数器，记录对某个资源（共享内存）的存取情况。

从定义来看，信号量底层使用到了spin lock的锁定机制，这个spinlock主要用来确保对count成员的原子操作

使用的大致方式：

1）测试控制该资源的信号量

2）若此信号量为正，允许使用，进程将信号量-1

3）若信号量=0，则不可使用，进程进入睡眠状态，直到信号量大于0，进程被resume，jump to step1）.

4）但进程不再使用一个信号量控制资源时，信号量+1，测试如果有进程正在等待此信号量，唤醒此进程。



互斥锁：

互斥主要现在了互相排斥（mutual exclusion）同步的简单形式，所以也叫mutex（互斥体）。

互斥体禁止多个线程同时进入受保护的代码临界区。因此，任何时刻，只有一个线程被允许进入这样的代码保护区

mutex实际上是count=1情况下的semaphore。而我们开发用的最多的锁就是mutex。



自旋锁：

任何时刻，最多只能有一个保持者

区别于mutex：

对于mutex，如果资源已经被占用，资源的申请者只能进入suspend状态

但是自旋锁不会引起调用者suspend，如果自旋锁已经被别的单元持有，调用者会一直循环查看该锁是否释放（自旋的含义）

最大的区别，自旋锁不会suspend



自旋锁和互斥锁的对比：

信号量/互斥体 **允许进程睡眠属于** **睡眠锁** ，自旋锁则 **不允许调用者睡眠** **，而是让其** **循环等待** ，所以有以下区别应用 

1）、信号量和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因而自旋锁适合于保持时间非常短的情况 

2）、 **自旋锁可以用于中断，不能用于** **进程上下文** **(会引起死锁)** 。而 **信号量不允许使用在中断中，而可以用于进程上下文** 

3）、自旋锁保持期间是抢占失效的，自旋锁被持有时，内核不能被抢占，而 **信号量和读写信号量保持期间是可以被抢占的（意味着可以被中断）**

**使用场所：**

**信号量主要适用于进程间通信，当然，也可用于线程间通信。**

**而互斥锁只能用于线程间通信。**



参考: http://blog.csdn.net/u012719256/article/details/52670098



## 自旋锁引起的死机情况

> 自旋锁最多只能被一个可执行线程持有（读写自旋锁除外）。自旋锁不会引起调用者睡眠，如果一个执行线程试图获得一个已经被持有的自旋锁，那么线程就会一直进行忙循环，一直等待下去（一直占用 CPU ），在那里看是否该自旋锁的保持者已经释放了锁， " 自旋 " 一词就是因此而得名。
>
> 由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。
>
> 信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因此只能在进程上下文使用（因为中断的上下文不允许休眠）（ _trylock 的变种能够在中断上下文使用）；而自旋锁 适合于保持时间非常短的情况，因为一个被争用的自旋锁使得请求它的线程在等待重新可用时自旋，特别浪费处理时间，这是自旋锁的要害之处，所以自旋锁不应该 被长时间持有。在实际应用中自旋锁代码只有几行，而持有自旋锁的时间也一般不会超过两次上下方切换，因线程一旦要进行切换，就至少花费切出切入两次，自旋 锁的占用时间如果远远长于两次上下文切换，我们就可以让线程睡眠，这就失去了设计自旋锁的意义。



> 如果被保护的共享资源只在进程上下文访问，使用信号量保护该共享资源非常合适，如果对共享资源的访问时间非常短，自旋锁也可以。但是如果被保护的共享资源需要在中断上下文访问（包括底半部即中断处理句柄和顶半部即软中断），就必须使用自旋锁。



> **自旋锁保持期间是抢占失效的（内核不允许被抢占）** ，而信号量保持期间是可以被抢占的。**自旋锁只有在内核可抢占或 SMP 的情况下才真正需要，在单 CPU 且不可抢占的内核下，自旋锁的所有操作都是空操作。**
>
> **注意，如果在一个已经对某个自旋锁加锁的进程的临界区中又申请对这个自旋锁加锁，则会导致进程自旋在那里，引起死机。**



> 因为自旋锁在同一时刻至多被一个执行线程持有，所以一个时刻只能有一个线程位于临界区，这就为多处理器提供了防止并发访问所需的保护机制，但是在单处理器上，编译的时候不会加入自旋锁。它仅仅被当作一个设置内核抢占机制是否被启用的开关**（ gx 自己的理解：在单内核可抢占式内核中，对自旋锁加锁导致禁止抢占，对自旋锁解锁导致恢复抢占模式。）。** 注意， Linux 内核实现的自旋锁是不可递归的，这一点不同于自旋锁 在其他操作系统中的实现，如果你想得到一个你正持有的锁，你必须自旋，等待你自己释放这个锁，但是你处于自旋忙等待中，所以永远没有机会释放锁，于是你就 被自己锁死了，一定要注意！
>
> 自旋锁可以用在中断处理程序中，但是在使用时一定要在获取锁之前，首先禁止本地中断（当前处理器上的中 断），否则中断处理程序就可能打断正持有锁的内核代码，有可能会试图争用这个已经被持有的自旋锁。这样一来，中断处理程序就会自旋，等待该锁重新可用， 但是锁的持有者在这个中断处理程序执行完毕之前不可能运行，这就会造成双重请求死锁。这个概念和“***\**\*如果在一个已经对某个自旋锁加锁的进程的临界区中又申请对这个自旋锁加锁，则会导致进程自旋在那里，引起死机\*\**\***”是一样的。



> -------- 自旋锁对信号量 ------------------------------------------------------
>
> 需求                   建议的加锁方法
>
> 低开销加锁               优先使用自旋锁
>
> 短期锁定               优先使用自旋锁
>
> 长期加锁               优先使用信号量
>
> 中断上下文中加锁          使用自旋锁
>
> 持有锁是需要睡眠、调度      使用信号量



参考:

[自旋锁与信号量的区别](https://blog.csdn.net/wangshuchangfrank/article/details/20834507?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control)



### 进程上下文与中断上下文的理解

参考:

[Linux 网络协议栈之内核锁（四）—— 进程上下文与中断上下文的理解](https://blog.csdn.net/zqixiao_09/article/details/79265902)