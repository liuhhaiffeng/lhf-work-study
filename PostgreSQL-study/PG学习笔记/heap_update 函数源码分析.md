# heap_update 函数源码分析

by 刘海峰 2020.12.13

## 背景

heap_update函数实现sql update中"替换一个tuple行".  了解heap_update的实现原理, 有助于更好的理解PG内核相关的MVCC, 事务, 可见性等机制.

## 分析策略

## 概述

### 函数注释整理了解

先通过heap_update的函数注释来整体了解此函数的作用.

```c
/*
 *	heap_update - replace a tuple
 *  替换一行
 
 * NB: do not call this directly unless you are prepared to deal with
 * concurrent-update conditions.  Use simple_heap_update instead.
 * 注: 不要直接调用此函数，除非你准备处理并发更新状况. 优先使用simple_heap_update.
 * 
 *  参数说明:
 *
 *	relation - table to be modified (caller must hold suitable lock)
 *  relation - 目标relation(调用者必须已经对relation加上了合适的锁)
 
 *	otid - TID of old tuple to be replaced
    otid - 准备要更新的tuple的tid (tuple id)
    
 *	newtup - newly constructed tuple data to store
    newtup - 新构造的tuple data, 在heap_update中会将此tuple data中的数据存储到新行
    
 *	cid - update command ID (used for visibility test, and stored into
 *		cmax/cmin if successful)
    cid - 更新的command ID (用于可见性检查, 如果更新成功, 会将此参数存入到新tuple的cmax和cmin字段中
    
 *	crosscheck - if not InvalidSnapshot, also check old tuple against this
    crosscheck - corsscheck是个snapshot, 用于用户提供的"交叉检查"
    
 *	wait - true if should wait for any conflicting update to commit/abort
    wait - 更新冲突时, 是否需要等待
    
 *	hufd - output parameter, filled in failure cases (see below)
    hufd - [out] 更新失败时, 填充的失败信息
    
 *	lockmode - output parameter, filled with lock mode acquired on tuple
    lockmode - [out] 在获取的行上施加的锁信息
 *
 * Normal, successful return value is HeapTupleMayBeUpdated, which
 * actually means we *did* update it.  Failure return codes are
 * HeapTupleSelfUpdated, HeapTupleUpdated, or HeapTupleBeingUpdated
 * (the last only possible if wait == false).
 * 正常下, 更新成功返回HeapTupleMayBeUpdated, 此值表示我们可以更新. 失败返回的值有
   HeapTupleSelfUpdated, HeapTupleUpdated, or HeapTupleBeingUpdated,
   其中仅当并且参数wait == false时, 才会返回 HeapTupleBeingUpdated
   
 * On success, the header fields of *newtup are updated to match the new
 * stored tuple; in particular, newtup->t_self is set to the TID where the
 * new tuple was inserted, and its HEAP_ONLY_TUPLE flag is set iff a HOT
 * update was done.  However, any TOAST changes in the new tuple's
 * data are not reflected into *newtup.
   更新成功时, *newtup的header fields会被更新, TODO; 
   尤其是, newtup->t_self 会被设置为"新行插入"的TID, 并且如果是一个HOT更新, 那么其 HEAP_ONLY_TUPLE
   flag也会被设置 (注: hot链上的dead tupe会设置为HEAP_HOT_UPDATED, 最新有效的会设置为 HEAP_ONLY_TUPLE)
   但是, 如果更新的TOAST, 则new tuple的数据不会反映在*newtup上, TOAST有一套单独的流程, 其不会存储在当前
   relation中, 其会存储在另外的toast relation中.
   
 * In the failure cases, the routine fills *hufd with the tuple's t_ctid,
 * t_xmax (resolving a possible MultiXact, if necessary), and t_cmax
 * (the last only for HeapTupleSelfUpdated, since we
 * cannot obtain cmax from a combocid generated by another transaction).
 * See comments for struct HeapUpdateFailureData for additional info.
   失败情况下, 此函数会将相关字段信息填充到*hufd中.
 */
HTSU_Result
heap_update(Relation relation, ItemPointer otid, HeapTuple newtup,
			CommandId cid, Snapshot crosscheck, bool wait,
			HeapUpdateFailureData *hufd, LockTupleMode *lockmode)
```

### 如何获得page结构

```c
block = ItemPointerGetBlockNumber(otid);
buffer = ReadBuffer(relation, block);
page = BufferGetPage(buffer);
```

根据入参otid可以找到块(block), 然后根据入参relation和block, 可以在bufpool中找到(或加载到)对应buffer(buffer只是一个bufpool中的id), 根据buffer就可以得到page结构, 这样就获取到了page结构了.

### 如何构造oldtup 的tuple data

```c
	LockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE);

	lp = PageGetItemId(page, ItemPointerGetOffsetNumber(otid));
	Assert(ItemIdIsNormal(lp));

/*
	 * Fill in enough data in oldtup for HeapDetermineModifiedColumns to work
	 * properly.
	 */
	oldtup.t_tableOid = RelationGetRelid(relation);
	oldtup.t_data = (HeapTupleHeader) PageGetItem(page, lp);
	oldtup.t_len = ItemIdGetLength(lp);
	oldtup.t_self = *otid;
```

对buffer加锁后, 就可以对page进行读写访问了, 根据otid, 从page中获取otid的line pointer.

如此, 根据相关的入参, 就可以构造一个 HeapTupleData oldtup了.

###  更新的可见性判断

```c
result = HeapTupleSatisfiesUpdate(&oldtup, cid, buffer);
```

根据构造好的oldtup, cid 以及buffer, 来进行更新的可见性判断.

### 根据可见性结果进行不同的处理

#### HeapTupleInvisible

不应该出现这种情况.

#### HeapTupleBeingUpdated && wait

这个分支, 说明更新存在冲突, 需要等待. 更新冲突时, oldtup的xmax肯定是有效的xid, 并且infomask标志此xmax当前是一个"事务锁".

(注: xmax是一个有效的xid时, 有两种情况: 一是表示此tuple被删除了, xmax是删除此tuple的事务号; 另一个是此tuple正在被其他事务更新, 

 此时的xmax表示一个"事务锁定")



```c
/* must copy state data before unlocking buffer */
		xwait = HeapTupleHeaderGetRawXmax(oldtup.t_data);
		infomask = oldtup.t_data->t_infomask;
```

1. 获取需要等待完结的事务号(xwait)
2. 获取infomask, 下面会对infomask的标记进行对应的判断

##### 组合事务 (infomask & HEAP_XMAX_IS_MULTI)

TODO 先不看

##### 当前事务 (TransactionIdIsCurrentTransactionId(xwait))

TODO 先不看

##### HEAP_XMAX_IS_KEYSHR_LOCKED(infomask) && key_intact

TODO 先不看

##### *Wait for regular transaction to end* (重点 ***)

```c
/*
			 * Wait for regular transaction to end; but first, acquire tuple
			 * lock.
			 */
			LockBuffer(buffer, BUFFER_LOCK_UNLOCK);
			heap_acquire_tuplock(relation, &(oldtup.t_self), *lockmode,
								 LockWaitBlock, &have_tuple_lock);
			XactLockTableWait(xwait, relation, &oldtup.t_self,
							  XLTW_Update);
			checked_lockers = true;
			LockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE);
```

1. 释放块锁

   因为下面可能涉及等待, 所以这里, 不应该长期持有块锁, 所以先将快速释放掉.

2. 在等待事务之前, 先施加行锁

   因为锁策略是LockWaitBlock, 所以 have_tuple_lock一定为true.

3. 等待事务完结

4. 等待事务完结后, 在重新获取块锁

   

```c
/*
			 * xwait is done, but if xwait had just locked the tuple then some
			 * other xact could update this tuple before we get to this point.
			 * Check for xmax change, and start over if so.
			 */
			if (xmax_infomask_changed(oldtup.t_data->t_infomask, infomask) ||
				!TransactionIdEquals(xwait,
									 HeapTupleHeaderGetRawXmax(oldtup.t_data)))
				goto l2;

			/* Otherwise check if it committed or aborted */
			UpdateXmaxHintBits(oldtup.t_data, buffer, xwait);
			if (oldtup.t_data->t_infomask & HEAP_XMAX_INVALID)
				can_continue = true;
		}

		result = can_continue ? HeapTupleMayBeUpdated : HeapTupleUpdated;
```

1. 等待事务完结后,  检查infomask是否被修改或者又有了新的xwait, 如果出现这2种情况, 那么继续返回 l2代码处, 继续等待.

2. 否则, 更新infomask上xmax的标志位状态
3. 如果 (oldtup.t_data->t_infomask & HEAP_XMAX_INVALID) == true, 则返回HeapTupleMayBeUpdated, 否则返回HeapTupleUpdated

###### 疑问 1 这里什么情况下会 goto l2?

### crosscheck != InvalidSnapshot && result == HeapTupleMayBeUpdated

```c
	result = can_continue ? HeapTupleMayBeUpdated : HeapTupleUpdated;
	}

	if (crosscheck != InvalidSnapshot && result == HeapTupleMayBeUpdated)
	{
		/* Perform additional check for transaction-snapshot mode RI updates */
		if (!HeapTupleSatisfiesVisibility(&oldtup, crosscheck, buffer))
			result = HeapTupleUpdated;
	}
```

上面逻辑判断出result == HeapTupleMayBeUpdated, 这里, 如果调用者入参提供了一个有效的crosscheck , 那么还需要根据调用者提供的crosscheck再做进一步的检查. 从上面的注释可以知道, 提供crosscheck检查, 是为了应对"transaction-snapshot mode RI updates"这一情况的.

RI updates 即 *referential integrity updates*.

### result != HeapTupleMayBeUpdated

```c
if (result != HeapTupleMayBeUpdated)
	{
		Assert(result == HeapTupleSelfUpdated ||
			   result == HeapTupleUpdated ||
			   result == HeapTupleBeingUpdated);
		Assert(!(oldtup.t_data->t_infomask & HEAP_XMAX_INVALID));
		hufd->ctid = oldtup.t_data->t_ctid;
		hufd->xmax = HeapTupleHeaderGetUpdateXid(oldtup.t_data);
		if (result == HeapTupleSelfUpdated)
			hufd->cmax = HeapTupleHeaderGetCmax(oldtup.t_data);
		else
			hufd->cmax = InvalidCommandId;
		UnlockReleaseBuffer(buffer);
		if (have_tuple_lock)
			UnlockTupleTuplock(relation, &(oldtup.t_self), *lockmode);
		if (vmbuffer != InvalidBuffer)
			ReleaseBuffer(vmbuffer);
		bms_free(hot_attrs);
		bms_free(key_attrs);
		bms_free(id_attrs);
		bms_free(modified_attrs);
		bms_free(interesting_attrs);
		return result;
	}
```

这里就是函数注释中说的, 失败的情况了, 更新失败时, 有如下才操作:

1. 填充 hufd
2. 如果有行锁, 则释放行锁
3. 相关是否 bms_free
4. 返回失败的结果值



### 小概率情况处理

```c
/*
	 * If we didn't pin the visibility map page and the page has become all
	 * visible while we were busy locking the buffer, or during some
	 * subsequent window during which we had it unlocked, we'll have to unlock
	 * and re-lock, to avoid holding the buffer lock across an I/O.  That's a
	 * bit unfortunate, especially since we'll now have to recheck whether the
	 * tuple has been locked or updated under us, but hopefully it won't
	 * happen very often.
	 */
	if (vmbuffer == InvalidBuffer && PageIsAllVisible(page))
	{
		LockBuffer(buffer, BUFFER_LOCK_UNLOCK);
		visibilitymap_pin(relation, block, &vmbuffer);
		LockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE);
		goto l2;
	}
```

#### 疑问 不懂?

### 成功后的处理 (HeapTupleMayBeUpdated)

执行到 " Fill in transaction status data (填写事务状态数据)"这一行时, heap_update的result 为 HeapTupleMayBeUpdated. 说明可以在目标行(oldtup)进行更新. 下面是更新相关的处理.

```c
/*
	 * If the tuple we're updating is locked, we need to preserve the locking
	 * info in the old tuple's Xmax.  Prepare a new Xmax value for this.
	 */
	compute_new_xmax_infomask(HeapTupleHeaderGetRawXmax(oldtup.t_data),
							  oldtup.t_data->t_infomask,
							  oldtup.t_data->t_infomask2,
							  xid, *lockmode, true,
							  &xmax_old_tuple, &infomask_old_tuple,
							  &infomask2_old_tuple);
```

step1: 计算新的xmax infomask.



```c
/*
	 * And also prepare an Xmax value for the new copy of the tuple.  If there
	 * was no xmax previously, or there was one but all lockers are now gone,
	 * then use InvalidXid; otherwise, get the xmax from the old tuple.  (In
	 * rare cases that might also be InvalidXid and yet not have the
	 * HEAP_XMAX_INVALID bit set; that's fine.)
	 */
	if ((oldtup.t_data->t_infomask & HEAP_XMAX_INVALID) ||
		HEAP_LOCKED_UPGRADED(oldtup.t_data->t_infomask) ||
		(checked_lockers && !locker_remains))
		xmax_new_tuple = InvalidTransactionId;
	else
		xmax_new_tuple = HeapTupleHeaderGetRawXmax(oldtup.t_data);
```

step2: 同时, 也为新的tuple准备好xmax值.



```c
if (!TransactionIdIsValid(xmax_new_tuple))
	{
		infomask_new_tuple = HEAP_XMAX_INVALID;
		infomask2_new_tuple = 0;
	}
	else
	{
		/*
		 * If we found a valid Xmax for the new tuple, then the infomask bits
		 * to use on the new tuple depend on what was there on the old one.
		 * Note that since we're doing an update, the only possibility is that
		 * the lockers had FOR KEY SHARE lock.
		 */
		if (oldtup.t_data->t_infomask & HEAP_XMAX_IS_MULTI)
		{
			GetMultiXactIdHintBits(xmax_new_tuple, &infomask_new_tuple,
								   &infomask2_new_tuple);
		}
		else
		{
			infomask_new_tuple = HEAP_XMAX_KEYSHR_LOCK | HEAP_XMAX_LOCK_ONLY;
			infomask2_new_tuple = 0;
		}
	}
```

step3: 



```c
/*
	 * Prepare the new tuple with the appropriate initial values of Xmin and
	 * Xmax, as well as initial infomask bits as computed above.
	 */
	newtup->t_data->t_infomask &= ~(HEAP_XACT_MASK);
	newtup->t_data->t_infomask2 &= ~(HEAP2_XACT_MASK);
	HeapTupleHeaderSetXmin(newtup->t_data, xid);
	HeapTupleHeaderSetCmin(newtup->t_data, cid);
	newtup->t_data->t_infomask |= HEAP_UPDATED | infomask_new_tuple;
	newtup->t_data->t_infomask2 |= infomask2_new_tuple;
	HeapTupleHeaderSetXmax(newtup->t_data, xmax_new_tuple);
```

step4: 准备new tuple, 初始化好合适的xmin和xmax, 以及infomask.



```c
/*
	 * Replace cid with a combo cid if necessary.  Note that we already put
	 * the plain cid into the new tuple.
	 */
	HeapTupleHeaderAdjustCmax(oldtup.t_data, &cid, &iscombo);
```

step5: 如有必要, 更新cid.



```c
/*
	 * If the toaster needs to be activated, OR if the new tuple will not fit
	 * on the same page as the old, then we need to release the content lock
	 * (but not the pin!) on the old tuple's buffer while we are off doing
	 * TOAST and/or table-file-extension work.  We must mark the old tuple to
	 * show that it's locked, else other processes may try to update it
	 * themselves.
	 *
	 * We need to invoke the toaster if there are already any out-of-line
	 * toasted values present, or if the new tuple is over-threshold.
	 */
	if (relation->rd_rel->relkind != RELKIND_RELATION &&
		relation->rd_rel->relkind != RELKIND_MATVIEW)
	{
		/* toast table entries should never be recursively toasted */
		Assert(!HeapTupleHasExternal(&oldtup));
		Assert(!HeapTupleHasExternal(newtup));
		need_toast = false;
	}
	else
		need_toast = (HeapTupleHasExternal(&oldtup) ||
					  HeapTupleHasExternal(newtup) ||
					  newtup->t_len > TOAST_TUPLE_THRESHOLD);
```

step6: 处理可能的toaster情况.



#### *to do the actual update*



## 知识点总结

### Q 更新后, 新版本tuple的xmax是否一定为0?

不一定. 并发更新时, 新版本tuple的xmax不一定为0(即 InvalidTransactionId).

```c
/*
	 * And also prepare an Xmax value for the new copy of the tuple.  If there
	 * was no xmax previously, or there was one but all lockers are now gone,
	 * then use InvalidXid; otherwise, get the xmax from the old tuple.  (In
	 * rare cases that might also be InvalidXid and yet not have the
	 * HEAP_XMAX_INVALID bit set; that's fine.)
	 * 
	 * 一般我的理解, new copy of the tuple 的 xmax一定是invalidxid, 看这里的代码逻辑,
	 * 说明这只是一种情况, 还有一种是我之前未知的. 估计和组合事务有关.
	 * TODO: 需要理解
	 * 
	 * 将目前的理解记录如下:
	 * 1. 
	 *    a. (oldtup.t_data->t_infomask & HEAP_XMAX_INVALID):
	 *       heap_update 为HeapTupleMayBeUpdated,  并且修改此tuple的事务
	 *       (即xmax, crash或abort), 那么我新版本tuple的xmax为invalidxid
	 *    b. HEAP_LOCKED_UPGRADED(oldtup.t_data->t_infomask) 
	 *       tuple是否是从pg9.2或之前版本升级上来的(in 9.2 or earlier and then pg_upgrade'd),
	 *       对于这种情况, 新版本tuplexmax为invalidxid
	 *    c. (checked_lockers && !locker_remains)
	 *       好像和组合事务有关, checked_lockers表示"锁等待了", locker_remains表示锁等待后, old tup
	 *       xmax上还有锁定(如: 组合事务读锁定)
	 *       (checked_lockers && !locker_remains) : 表示等待过锁了, 并且等待之后, old tup的
	 *       xmax上没有锁定了, 那么新版本tuple的xmax为invalidxid
	 * 2. 除过"1"上面的3种情况, old tup xmax仍然存在锁定, 那么需要将此old tup xmax赋值给新版本tuple的
	 *    xmax
	 *    TODO: 这样做的目的为何呢? 和MVCC有关? 和组合事务有关? 
	 *          注: 个人感觉, 还是和组合事务有关, 即一个tuple可以让你更新, 但你的新版本的xmax还是old tup
	 *              xmax, 这样的"读取或操作"你的新版本时, 你新版本上的这个有效的xmax的影响就需要考虑了.
	 *              至于什么影响, 目前我还不知道.
	 * 
	 */
	if ((oldtup.t_data->t_infomask & HEAP_XMAX_INVALID) ||
		HEAP_LOCKED_UPGRADED(oldtup.t_data->t_infomask) ||
		(checked_lockers && !locker_remains))
		xmax_new_tuple = InvalidTransactionId;
	else
		xmax_new_tuple = HeapTupleHeaderGetRawXmax(oldtup.t_data);
```



### Q heap_update中hot机制的启用条件?

数据库行数据更新时，索引也需要进行维护，如果是高并发的情况下，索引维护的代价很大，可能造成索引分裂。

为了尽可能减小索引更新的代价，引入HOT（堆内元组技术）。 

HOT使用的条件:

​	1、新老数据行必须位于同一个数据块内。(注: 这里隐含一个条件: PageIsFull(page) == false)

​	2、更新的列上如果有索引，此列上的索引不能使用HOT技术。

> 参考: 
>
> 1. svn://192.30.1.2/svn/uxdb/40.部门管理/01.产品研发部/02.能力提升/01.经验总结/Vacuum机制_焦兰兰.pptx  自动清理-HOT链清理

hot机制的启用条件如下:

```c
if (newbuf == buffer)
	{
		/*
		 * Since the new tuple is going into the same page, we might be able
		 * to do a HOT update.  Check if any of the index columns have been
		 * changed. If the page was already full, we may have skipped checking
		 * for index columns. If so, HOT update is possible.
		 * 由于新的元组将进入相同的页面，我们可能会*进行热更新。检查是否有索引列被*更改。
		 * 如果页面已经满了，我们可能跳过了索引列的检查*。如果是这样，热更新是可能的。
		 * 注: 1. newbuf == buffer 说明更新在同一个块中
		 *     2. hot_attrs_checked == true 说明 PageIsFull() == false
		 *     3. !bms_overlap(modified_attrs, hot_attrs) 说明modified_attrs和hot_attrs没有交集,
		 *        modified_attrs是要更新的tuple列, hot_attrs是索引列, 这里的意思是"更新的列上如果有索引,
		 *        那么此列上的索引不能使用hot技术"		
		 */
		if (hot_attrs_checked && !bms_overlap(modified_attrs, hot_attrs))
			use_hot_update = true;
	}
```

hot和非hot更新具体实现如下:

```c
if (use_hot_update)
	{
		/* Mark the old tuple as HOT-updated */
		HeapTupleSetHotUpdated(&oldtup);
		/* And mark the new tuple as heap-only */
		HeapTupleSetHeapOnly(heaptup);
		/* Mark the caller's copy too, in case different from heaptup */
		HeapTupleSetHeapOnly(newtup);
	}
	else
	{
		/* Make sure tuples are correctly marked as not-HOT */
		HeapTupleClearHotUpdated(&oldtup);
		HeapTupleClearHeapOnly(heaptup);
		HeapTupleClearHeapOnly(newtup);
	}
```



### Q 如何根据tid获得page结构体?

```c
	block = ItemPointerGetBlockNumber(otid);	/* 根据otid获得块号 */
	buffer = ReadBuffer(relation, block);		/* 返回目标块在bufpool中的id, 如果不在bufpool, 则先从磁盘加载到bufpool */
	page = BufferGetPage(buffer);				/* 根据buffer id 获得块结构体(page) */
```

### Q 如何根据tid获得tuple结构体?

```c
	block = ItemPointerGetBlockNumber(otid);	/* 根据otid获得块号 */
	buffer = ReadBuffer(relation, block);		/* 返回目标块在bufpool中的id, 如果不在bufpool, 则先从磁盘加载到bufpool */
	page = BufferGetPage(buffer);				/* 根据buffer id 获得块结构体(page) */

	lp = PageGetItemId(page, ItemPointerGetOffsetNumber(otid));
	Assert(ItemIdIsNormal(lp));

		/*
	 * Fill in enough data in oldtup for HeapDetermineModifiedColumns to work
	 * properly.
	 */
	oldtup.t_tableOid = RelationGetRelid(relation);
	oldtup.t_data = (HeapTupleHeader) PageGetItem(page, lp);
	oldtup.t_len = ItemIdGetLength(lp);
	oldtup.t_self = *otid;
```

### Q heap_update中checked_lockers, locker_remains和can_continue的作用?

TODO

#### can_continue

```c
result = can_continue ? HeapTupleMayBeUpdated : HeapTupleUpdated;
```

### Q hot_attrs, key_attrs和id_attrs说明

```c
	hot_attrs = RelationGetIndexAttrBitmap(relation, INDEX_ATTR_BITMAP_ALL);
	key_attrs = RelationGetIndexAttrBitmap(relation, INDEX_ATTR_BITMAP_KEY);
	id_attrs = RelationGetIndexAttrBitmap(relation,
										  INDEX_ATTR_BITMAP_IDENTITY_KEY);
```

```c
typedef enum IndexAttrBitmapKind
{
	INDEX_ATTR_BITMAP_ALL,		/* 获取索引上的所有列集合 */
	INDEX_ATTR_BITMAP_KEY,		/* 获取索引上和外键有关的列集合 */
	INDEX_ATTR_BITMAP_PRIMARY_KEY,	/* 获取索引上和主键有关的列集合 */
	INDEX_ATTR_BITMAP_IDENTITY_KEY	/* 和逻辑复制有关 */
} IndexAttrBitmapKind;
```

#### hot_attrs

```c
	hot_attrs = RelationGetIndexAttrBitmap(relation, INDEX_ATTR_BITMAP_ALL);
```

hot机制和索引表的所有列都相关.

#### key_arrtrs

```c
/*
	 * If we're not updating any "key" column, we can grab a weaker lock type.
	 * This allows for more concurrency when we are running simultaneously
	 * with foreign key checks.
	 *
	 * Note that if a column gets detoasted while executing the update, but
	 * the value ends up being the same, this test will fail and we will use
	 * the stronger lock.  This is acceptable; the important case to optimize
	 * is updates that don't manipulate key columns, not those that
	 * serendipitiously arrive at the same key values.
	 */
	if (!bms_overlap(modified_attrs, key_attrs))
	{
		*lockmode = LockTupleNoKeyExclusive;	/* update不修改key列, 那么获取一个较弱的锁, 以便提高并发度 */
		mxact_status = MultiXactStatusNoKeyUpdate;
		key_intact = true;

		/*
		 * If this is the first possibly-multixact-able operation in the
		 * current transaction, set my per-backend OldestMemberMXactId
		 * setting. We can be certain that the transaction will never become a
		 * member of any older MultiXactIds than that.  (We have to do this
		 * even if we end up just using our own TransactionId below, since
		 * some other backend could incorporate our XID into a MultiXact
		 * immediately afterwards.)
		 */
		MultiXactIdSetOldestMember();
	}
	else
	{
		*lockmode = LockTupleExclusive;		/* update修改key列, 那么只能获取一个强锁 */
		mxact_status = MultiXactStatusUpdate;
		key_intact = false;
	}
```

如果更新的列中不涉及key列, 那么则: 1. 可以获取一个弱锁(而非强锁), 当我们同时运行(*with foreign key checks*), 可以有更多的并发.

#### id_attrs

```c
/*
	 * Compute replica identity tuple before entering the critical section so
	 * we don't PANIC upon a memory allocation failure.
	 * ExtractReplicaIdentity() will return NULL if nothing needs to be
	 * logged.
	 * 
	 * 这里和流复制有关了, 暂时先不看.
	 */
	old_key_tuple = ExtractReplicaIdentity(relation, &oldtup,
										   bms_overlap(modified_attrs, id_attrs),
										   &old_key_copied);
```

参考: [REPLICA IDENTITY](https://blog.csdn.net/u012551524/article/details/89845167)

[PostgreSQL Identity Column](https://www.postgresqltutorial.com/postgresql-identity-column/)

TODO 待预研

### Q tuple清理是否只有vacuum?

不是, 除过vacuum, 还有一个 page prun.

```c
/*
	 * If this transaction commits, the old tuple will become DEAD sooner or
	 * later.  Set flag that this page is a candidate for pruning once our xid
	 * falls below the OldestXmin horizon.  If the transaction finally aborts,
	 * the subsequent page pruning will be a no-op and the hint will be
	 * cleared.
	 *
	 * XXX Should we set hint on newbuf as well?  If the transaction aborts,
	 * there would be a prunable tuple in the newbuf; but for now we choose
	 * not to optimize for aborts.  Note that heap_xlog_update must be kept in
	 * sync if this decision changes.
	 * 
	 * TODO: 这里需要好好理解一下
	 */
	PageSetPrunable(page, xid);		

	if (use_hot_update)
	{
		/* Mark the old tuple as HOT-updated */
		HeapTupleSetHotUpdated(&oldtup);
		/* And mark the new tuple as heap-only */
		HeapTupleSetHeapOnly(heaptup);
		/* Mark the caller's copy too, in case different from heaptup */
		HeapTupleSetHeapOnly(newtup);
	}
	else
	{
		/* Make sure tuples are correctly marked as not-HOT */
		HeapTupleClearHotUpdated(&oldtup);
		HeapTupleClearHeapOnly(heaptup);
		HeapTupleClearHeapOnly(newtup);
	}
```

PageSetPrunable(page, xid)标记是否可以进行块内修剪(即清理).

### Q heap_update中如果成功, 新tuple是如何安插的?

```c
if (use_hot_update)
	{
		/* Mark the old tuple as HOT-updated */
		HeapTupleSetHotUpdated(&oldtup);
		/* And mark the new tuple as heap-only */
		HeapTupleSetHeapOnly(heaptup);
		/* Mark the caller's copy too, in case different from heaptup */
		HeapTupleSetHeapOnly(newtup);
	}
	else
	{
		/* Make sure tuples are correctly marked as not-HOT */
		HeapTupleClearHotUpdated(&oldtup);
		HeapTupleClearHeapOnly(heaptup);
		HeapTupleClearHeapOnly(newtup);
	}

	RelationPutHeapTuple(relation, newbuf, heaptup, false); /* insert new tuple 新版本tuple终于安插成功了 */
```

### Q heap_update中如果更新的是系统字典, 与无效消息相关的在哪里?

```c
	/*
	 * Mark old tuple for invalidation from system caches at next command
	 * boundary, and mark the new tuple for invalidation in case we abort. We
	 * have to do this before releasing the buffer because oldtup is in the
	 * buffer.  (heaptup is all in local memory, but it's necessary to process
	 * both tuple versions in one call to inval.c so we can avoid redundant
	 * sinval messages.)
	 * 当更新的表为"系统表"时, 此函数才有作用. 当系统表更新后, 调用此函数, 使系统字典缓存
	 * 无效, 以便发送无效消息同步系统缓存
	 * 
	 * 注: 根据注释, 此操作应该在"是否buffer ReleaseBuffer"之前执行
	 */
	CacheInvalidateHeapTuple(relation, &oldtup, heaptup);
```

### Q heap_update中与统计相关的在哪里?

```c
/* 统计相关 */
pgstat_count_heap_update(relation, use_hot_update);
```

## 知识点总结2

### heap_update 函数声明变量说明

```c
	HTSU_Result result;	/* 记录 heap_update 的返回值 */
	/* 分配的事务号, HeapTupleHeaderSetXmin, PageSetPrunable 使用 */
	TransactionId xid = GetCurrentTransactionId();	

	/* 相关的列 */
	Bitmapset  *hot_attrs;
	Bitmapset  *key_attrs;
	Bitmapset  *id_attrs;
	Bitmapset  *interesting_attrs;
	Bitmapset  *modified_attrs;

	ItemId		lp;
	HeapTupleData oldtup;
	HeapTuple	heaptup;

	/* 估计和逻辑复制有关 */
	HeapTuple	old_key_tuple = NULL;
	bool		old_key_copied = false;

	Page		page;
	BlockNumber block;
	MultiXactStatus mxact_status;	/* 组合事务状态 */

	/* 相关的buffer 
	 * 1. 数据块
	 * 2. vm数据块
	 */
	Buffer		buffer,
				newbuf,
				vmbuffer = InvalidBuffer,
				vmbuffer_new = InvalidBuffer;

	bool		need_toast;		/* toast 启动 */
	Size		newtupsize,
				pagefree;
	bool		have_tuple_lock = false;	/* 行锁相关 */
	bool		iscombo;

	/* hot机制相关 */
	bool		use_hot_update = false;
	bool		hot_attrs_checked = false;

	bool		key_intact;
	bool		all_visible_cleared = false;
	bool		all_visible_cleared_new = false;
	bool		checked_lockers;	/* 在update时, 是否在xmax上检测到锁了 */
	bool		locker_remains;		/* 等待锁定事务完结后, xmax上是否仍然还有锁定, 这个一般和组合事务有关 */
	TransactionId xmax_new_tuple,
				xmax_old_tuple;

	/* infomask 相关 */
	uint16		infomask_old_tuple,
				infomask2_old_tuple,
				infomask_new_tuple,
				infomask2_new_tuple;
```

### heap_update中的组合事务和行锁

#### 组合事务的锁模式

```c
/*
 * Possible multixact lock modes ("status").  The first four modes are for
 * tuple locks (FOR KEY SHARE, FOR SHARE, FOR NO KEY UPDATE, FOR UPDATE); the
 * next two are used for update and delete modes.
 */
typedef enum
{
	MultiXactStatusForKeyShare = 0x00,
	MultiXactStatusForShare = 0x01,
	MultiXactStatusForNoKeyUpdate = 0x02,
	MultiXactStatusForUpdate = 0x03,
	/* an update that doesn't touch "key" columns 一个不涉及“关键”列的更新 */
	MultiXactStatusNoKeyUpdate = 0x04,
	/* other updates, and delete 其他更新，并删除 */
	MultiXactStatusUpdate = 0x05
} MultiXactStatus;
```

前4个是行锁(tuple locks)用于*FOR KEY SHARE, FOR SHARE, FOR NO KEY UPDATE, FOR UPDATE*场景下. 后2个用于update和delete模式.

#### 与行锁有关的infomask

```c
/*
 * Use these to test whether a particular lock is applied to a tuple
 */
#define HEAP_XMAX_IS_SHR_LOCKED(infomask) \
	(((infomask) & HEAP_LOCK_MASK) == HEAP_XMAX_SHR_LOCK)
#define HEAP_XMAX_IS_EXCL_LOCKED(infomask) \
	(((infomask) & HEAP_LOCK_MASK) == HEAP_XMAX_EXCL_LOCK)
#define HEAP_XMAX_IS_KEYSHR_LOCKED(infomask) \
	(((infomask) & HEAP_LOCK_MASK) == HEAP_XMAX_KEYSHR_LOCK)
```

#### 锁升级

```c
/*
 * A tuple that has HEAP_XMAX_IS_MULTI and HEAP_XMAX_LOCK_ONLY but neither of
 * XMAX_EXCL_LOCK and XMAX_KEYSHR_LOCK must come from a tuple that was
 * share-locked in 9.2 or earlier and then pg_upgrade'd.
 *
 * In 9.2 and prior, HEAP_XMAX_IS_MULTI was only set when there were multiple
 * FOR SHARE lockers of that tuple.  That set HEAP_XMAX_LOCK_ONLY (with a
 * different name back then) but neither of HEAP_XMAX_EXCL_LOCK and
 * HEAP_XMAX_KEYSHR_LOCK.  That combination is no longer possible in 9.3 and
 * up, so if we see that combination we know for certain that the tuple was
 * locked in an earlier release; since all such lockers are gone (they cannot
 * survive through pg_upgrade), such tuples can safely be considered not
 * locked.
 *
 * We must not resolve such multixacts locally, because the result would be
 * bogus, regardless of where they stand with respect to the current valid
 * multixact range.
 */
#define HEAP_LOCKED_UPGRADED(infomask) \
( \
	 ((infomask) & HEAP_XMAX_IS_MULTI) != 0 && \
	 ((infomask) & HEAP_XMAX_LOCK_ONLY) != 0 && \
	 (((infomask) & (HEAP_XMAX_EXCL_LOCK | HEAP_XMAX_KEYSHR_LOCK)) == 0) \
)
```

## 参考文档

1. [PostgreSQL并发控制机制（2）： 表级锁和行级锁](http://www.postgres.cn/v2/news/viewone/1/632)

   > 并发控制是多个事务在并发运行时，数据库保证事务一致性（Consistency）和隔离性（Isolation）的一种机制。主流商用关系数据库使用的并发控制技术主要有三种：严格两阶段封锁（S2PL）、多版本并发控制（MVCC）和乐观并发控制（OCC）。
   > 在工程实践上，PostgreSQL使用了MVCC的一种变体快照隔离SI结合封锁技术进行并发控制，本文介绍了锁相关的部分理论以及PostgreSQL的工程实践，最后结合案例对PostgreSQL的表级锁和行级锁进行了相关介绍。

2. [PG社区强人随笔](http://www.postgres.cn/v2/news/typelist/1/%E5%BC%BA%E4%BA%BA%E9%9A%8F%E7%AC%94)