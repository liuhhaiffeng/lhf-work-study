# 各种数据库封锁协议说明

by 刘海峰 2020.12.08

## 概念

### 封锁

事务T在对某个数据对象，如表、记录等操作之前，需要先向系统发出加锁请求，在事务T释放它的锁之前，其他事务不能对此数据进行修改。

PG中的封锁指的是RegularLock. LWLock和SpinLock的加锁不属于事务封锁的概念范畴.  LWLock和SpinLock仅仅是事务管理中锁的底层实现.

## 封锁协议

### 三级封锁协议

一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。可防止丢失修改。

二级封锁协议：在一级封锁协议基础上增加事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。除防止丢失修改，还可进一步防止读“脏”数据。

三级封锁协议：在一级封锁协议基础上增加事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。除防止丢失修改和读“脏”数据外，还进一步防止了不可重复读。

[封锁协议与两段锁协议](https://blog.csdn.net/ben1010101010/article/details/84573100?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control)

### 一次性封锁协议

事务开始时，即一次性申请所有的锁，之后不会再申请任何锁，如果其中某个锁不可用，则整个申请就不成功，事务就不会执行，在事务尾端，一次性释放所有的锁。一次性锁协议不会产生死锁的问题，但事务的并发度不高。
可防止修改丢失.

https://www.cnblogs.com/zszmhd/p/3365220.html

### 两阶段封锁协议

整个事务分为两个阶段，前一个阶段为加锁，后一个阶段为解锁。在加锁阶段，事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段，此过程中事务只能解锁，也可以操作数据，不能再加锁。两阶段锁协议使得事务具有较高的并发度，因为解锁不必发生在事务结尾。它的不足是没有解决死锁的问题，因为它在加锁阶段没有顺序要求。如两个事务分别申请了A, B锁，接着又申请对方的锁，此时进入死锁状态。
除防止丢失修改，还可进一步防止读“脏”数据。

### 严格两阶段封锁协议

在2PL的基础上规定, 申请的锁, 只能等待事务结束(提交或回滚)时才能释放.



## 说明

数据库理论中的各种封锁协议很多, PG数据库(或者说商业数据库大多)使用的封锁协议主要有 2PL和S2PL.

对于上面的封锁协议仅做了解即可, 重点需要知道的是: 2PL封锁中, 可能会出现死锁, 因为2PL允许事务可以以任意的顺序来获取多个锁.

另外, 对于PG的2个内存操作锁(LWLock和SpinLock)记住, 它们没有所谓的"死锁".



在一般数据库理论中, 使用三级封锁协议, 可以实现"读已提交"和"可重复读"隔离级别, 甚至有所谓的"四级封锁协议"来保证实现"可串行化"隔离级别. 这个封锁协议是完全使用锁定机制来实现数据库ANSI要求的隔离级别, 而实际生产数据库不会采用这种封锁协议, 原因是: 性能太差. 个人理解, 上述封锁协议仅作为一种"教学"或"概念理解"使用, 类似于网络的ISO七层标准协议和TCP/IP协议一样.

在PG中, "MVCC+2PL"来实现"读已提交"和"可重复读"隔离级别, 另外通过S2PL来实现"可串行化"隔离级别.



